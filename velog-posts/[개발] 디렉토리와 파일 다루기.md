<p>터미널을 다루는게 프론트엔드 개발에 중요도가 높은 토픽은 아니지만, 개발을 시작하면서 만나게 되는 기초 지식이라 블로그에 작성하면 좋을 것 같았다. 원래는 기본 명령어 정도만 읽히기 쉽게 정리해보려고 했는데, 공부하면서 이것 저것 넣다보니 거의 모든 내용을 담아서 글이 엄청 길어져버렸다. . . ☺️🙄</p>
<p>개념까지 외우고 이해하려고 하기보다는 그냥 직접 입력해보면서 익혔는데, 처음엔 조금 복잡해보였어도 금방 익숙해질 만큼 직관적이고 재밌었다. </p>
<p>그만큼 기초적인 내용이라는 거겠지. . . ?
<br /><br /></p>
<h2 id="✅-유닉스-디렉토리-구조">✅ 유닉스 디렉토리 구조</h2>
<blockquote>
<p>유닉스 디렉토리 구조는 부모-자식 관계를 가지는 디렉토리들로 이루어져,
계층적인 <strong>트리 구조(계층적 구조)</strong>로 형성한다.</p>
</blockquote>
<p>모든 디렉토리의 출발점은 <code>루트(root)</code>.
<code>루트</code> 디렉토리는 파일 시스템의 최상위 디렉토리다.
<img alt="" src="https://velog.velcdn.com/images/iamsuuya/post/ecea1956-2f02-4648-9412-34508323d920/image.png" /></p>
<pre><code class="language-bash">$ ~/Documents/Projects
/home/Documents/Projects</code></pre>
<p>위에서 <code><del></code> 는 곧 <code>/home</code>까지의 디렉토리 경로를 줄여 쓴 것과 같으며 <code></del></code>로 축약해서 사용한다.
<br /></p>
<ul>
<li><strong>부모(상위) 디렉토리</strong>: 다른 디렉토리를 포함하는 디렉토리</li>
<li><strong>서브(하위) 디렉토리</strong>: 부모 디렉토리의 내부에 위치하는 디렉토리</li>
</ul>
<pre><code class="language-bash"># 예시 경로
~/user/documents
# 부모
~/user
# 자식
documents</code></pre>
<p><br /><br /></p>
<h2 id="✅-기본-명령어">✅ 기본 명령어</h2>
<p>자주 사용하는 기본 명령어에는 <code>pwd</code>, <code>cd</code>, <code>ls</code>가 있다.
그리고 아래와 같이 명령하여 사용 할 수 있다.
<br /></p>
<h3 id="pwd">pwd</h3>
<p><code><strong>pwd</strong>(Print Working Diectory)</code> : 현재 위치해 있는 디렉토리 경로를 확인할 때
🌠 <strong>워킹 디렉토리</strong>(Working Directory): 현재 위치에 있는 디렉토리. 작업 디렉토리라고도 함</p>
<pre><code class="language-bash">pwd
# 현재 위치
/Users/suya</code></pre>
<br />

<h3 id="cd">cd</h3>
<p><code><strong>cd</strong>(Change Directory)</code> : 현재 작업 중인 디렉토리를 이동 할 때</p>
<pre><code class="language-bash">cd [PATH]

cd                (홈 디렉토리로 이동)
cd path/to/foo    (foo 디렉토리로 이동)
cd path/to/bar    (bar 디렉토리로 이동)
cd -              (다시 foo 디렉토리로 이동. - 는 이전 경로로 이동)</code></pre>
<br />

<h3 id="ls">ls</h3>
<p><code><strong>ls</strong>(List의 줄임말)</code> : 디렉토리 내용(파일 및 하위 디렉토리)을 나열하는 명령어. 내용물을 살펴볼 때 사용한다.</p>
<pre><code class="language-bash"># PATH에 해당하는 디렉토리 / 파일 정보를 보여준다.
# PATH 아규먼트를 안 주면 현재 디렉토리 정보를 보여준다.
ls [-al] [PATH]</code></pre>
<h4 id="ls의-자주-사용하는-중요한-옵션들">ls의 자주 사용하는 중요한 옵션들</h4>
<p><code>-l(long format)</code>, <code>-a</code>, <code>-al</code></p>
<pre><code class="language-bash"># 자세한 정보를 보여주는 옵션
# 파일과 디렉토리를 자세한 형식(long format)으로 나열한다.
# 파일 종류, 파일 권한, 파일 소유자, 마지막 수정 시간, 파일 사이즈 등 여러 추가 정보
$ ls -l

# 숨겨진 파일과 디렉토리까지 모두 보여주는 옵션
# 파일 이름이 .(점)으로 시작하는 파일이나 디렉토리가 숨겨져 있는데,
# 그런 모든 파일과 디렉토리를 나열한다.
$ ls -a

# 위 두개의 옵션을 같이쓰는 것
$ ls -al</code></pre>
<br />

<p>🌠** 파일/디렉토리 이름에 공백이 있는 경우**</p>
<pre><code class="language-bash">cd hello world
ls hello world </code></pre>
<p>예를 들어, 홈 디렉토리 안에 <code>hello world</code>라는 디렉토리가 있다. 
홈 디렉토리에서 위의 커맨드를 실행하면 <code>hello, world</code> 두 개의 아규먼트로 인식하기 때문에 오류가 발생한다.
그래서 이름에 공백이 들어갈 때는 <code><strong>특수 기호</strong></code>를 사용해야 한다.</p>
<ol>
<li><code>''</code> 작은따옴표 사용<pre><code class="language-bash">cd 'hello world'</code></pre>
</li>
<li><code>""</code> 큰따옴표 사용<pre><code class="language-bash">cd &quot;hello world&quot;</code></pre>
</li>
<li><code>&lt;/code> 역슬래시 사용 (한국어 키보드에서는 <code>₩</code> 키)<pre><code class="language-bash">cd hello\ world</code></pre>
로 처리 가능하지만, 파일이나 디렉토리 이름에 공백 사용말고 언더바를 사용하자. 😀
<br /><br /></li>
</ol>
<h2 id="✅-루트root-안의-디렉토리">✅ 루트(root) 안의 디렉토리</h2>
<p>루트 디렉토리(/) 아래에는 수많은 디렉토리들이 있다.</p>
<h3 id="bin">/bin</h3>
<p><strong><code>bin(binaries)</code></strong>. 
<code>binary</code>는 간단히 말해서 <strong>컴퓨터가 실행할 수 있는 프로그램</strong>을 뜻한다. 
커맨드도 결국 어떤 프로그램이다. 커맨드를 입력하면 커맨드에 해당하는 프로그램이 실행되는 것. 
그리고 그 <strong>프로그램들의 일부는 바로 이 <code>/bin</code> 디렉토리 안에 있다.</strong> </p>
<pre><code class="language-bash"># 자세한 정보를 포함하여 /bin 디렉토리 목록 출력
ls -l /bin</code></pre>
<p><code>ls</code> 커맨드를 입력하면  <code>/bin</code> 안에 있는  <code>ls</code> 프로그램이 실행된다.
<br /></p>
<h3 id="sbin">/sbin</h3>
<p><code>sbin</code>은 <code>bin</code>과 비슷한데, <strong>관리자 전용 프로그램</strong>들이 있다.
<br /></p>
<h3 id="etc">/etc</h3>
<p><code>etc</code>에는 컴퓨터 설정 파일들이 있는데, 각종 <strong>프로그램의 설정 파일, 관리자 권한 설정 파일</strong> 같은 것들이 있다.
<br /></p>
<h3 id="usr">/usr</h3>
<p><code>usr</code>은 <strong>사용자(user)에게 필요한 파일</strong>들을 저장하고 있다. 
<code>/usr</code> 안에도 각종 binary(프로그램 파일)를 저장하고 있는 <code>bin</code> 디렉토리가 있는데, </p>
<ul>
<li><code>/bin</code>에는 <u>컴퓨터가 시작하거나 자신을 수리하기 위해서 꼭 필요한 커맨드</u>들이 있고, </li>
<li><code>/usr/bin</code>에는 컴퓨터가 필요하기보다는 <u>사용자가 필요한 커맨드</u>들이 있다.<br />

</li>
</ul>
<p><code>/usr</code> 안에는 <code>local</code>이라는 디렉토리도 있는데, 여기에는 <strong>사용자가 직접 설치한 프로그램과 관련된 파일</strong>들이 있다.
<br /><br /></p>
<h2 id="✅-디렉토리와-파일-만들어보기">✅ 디렉토리와 파일 만들어보기</h2>
<h3 id="mkdir">mkdir</h3>
<p><code>mkdir</code>은 make directory라는 줄임말.
<code>디렉토리</code>를 <code>생성</code>한다. 여러 경로를 한꺼번에 줘서 여러 디렉토리를 한꺼번에 만들 수 있다.</p>
<pre><code class="language-bash">mkdir PATH1 PATH2 ...</code></pre>
<br />

<h3 id="touch">touch</h3>
<p><code>touch</code>는 touch file.
<code>touch</code>는 말그대로 파일에 손을 대서 파일의 마지막 접근 시간이나 수정 시간을 업데이트하는 커멘드인데, 파일이 없으면 새로 생성하기 때문에 <code>파일 생성</code> 용도로도 쓰인다.</p>
<pre><code class="language-bash">touch PATH1 PATH2 ...</code></pre>
<br />

<p>예제 1) <code>home</code> &gt; <code>unix_practice</code> 디렉토리 만들기</p>
<pre><code class="language-bash">mkdir ~/unix_practice 또는
mkdir unix_practice(상대 경로)</code></pre>
<p>예제 2) <code>unix_practice</code> &gt; <code>reports</code> 디렉토리 만들기</p>
<pre><code class="language-bash">cd unix_practice
mkdir reports</code></pre>
<p>예제 3) <code>reports</code>에 회사의 보고서가 저장되어 있다고 생각하고, 월별로 보고서를 나누기 위해 안에 디렉토리를 여러개 만들기</p>
<pre><code class="language-bash">cd reports
mkdir Jul Aug Sep</code></pre>
<p>예제 4) 이제 각 파일도 만들어보자.</p>
<pre><code class="language-bash"># Jul 디렉토리로 이동하여,
cd Jul
# finances.txt, performance.txt 파일을 생성했다.
touch finances.txt performance.txt</code></pre>
<p>예제 5) 이제 8, 9월 폴더에도 txt 파일을 만들어봐.</p>
<pre><code class="language-bash"># 위로 이동해서 다른 폴더 안으로 이동해도 되는데,
# 자리에서 여러개를 만들어 줄 수도 있다.

# 나가자 ..
cd ..
# 그리고 여러개 입력
touch Aug/finances.txt Aug/performance.txt</code></pre>
<p><img src="https://velog.velcdn.com/images/iamsuuya/post/cf9acf0c-7b13-4cc8-83aa-9c6c194eb698/image.png" width="100%" /> 궁금해서 위 예제를 한꺼번에 한 줄로 처리해봤다.
된다, 짱 편하다. . . 😀</p>
<p><br /><br /></p>
<h2 id="✅-cli-텍스트-에디터">✅ CLI 텍스트 에디터</h2>
<p>위에서 파일을 만드는 방법을 배웠으니, 이번에는 <strong>파일의 내용을 작성하는 방법</strong>을 배워보자.</p>
<p>GUI 환경에서는 <code>VS Code</code>, <code>Word</code>와 같은 에디터를 사용하면 되지만,  <code>CLI</code> 환경에서는 <code>Vim</code>이라는 <strong>전용 텍스트 에디터</strong>를 사용한다. </p>
<h3 id="vim">vim</h3>
<p>vim에는 엄청나게 다양한 기능과 단축키가 있다.
vim의 단점이라면, 모든 걸 마우스 없이 키보드만으로 해결해야한다는 점이다.</p>
<h4 id="✅-vim-실행하기">✅ vim 실행하기</h4>
<p><code>vim</code> 커맨드 입력</p>
<pre><code class="language-bash">vim</code></pre>
<p>파일 경로를 아규먼트로 주면 해당하는 파일을 열거나, 존재하지 않으면 새로 만들어 준다.</p>
<pre><code class="language-bash">vim path/to/file</code></pre>
<br />

<h4 id="✅-vim의-4가지-사용-모드">✅ vim의 4가지 사용 모드</h4>
<p>각 모드에서 아래와 같은 기능들을 사용할 수 있다.
이때, 사용자가 어떤 모드에 있는지에 따라 같은 키를 눌러도 다르게 해석 된다.</p>
<table border="1" width="100%">
  <thead>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
  </thead>
  <tbody>
    <tr>
      <th scope="col">일반 모드<br />(Normal Mode)</th>
      <th scope="col">입력 모드<br />(Insert Mode)</th>
      <th scope="col">비주얼 모드<br />(Visual Mode)</th>
      <th scope="col">명령 모드<br />(Command Mode)</th>
    </tr>
    <tr align="center">
          <td>esc 키</td>
        <td>i 키</td>
        <td>글자 복사 v 키, 줄 복사 V 키</td>
        <td>: 키</td>
    </tr>
    <tr align="center">
          <td>커서 이동</td>
        <td>텍스트 입력</td>
        <td>텍스트 블록 지정</td>
        <td>내용 저장</td>
    </tr>
    <tr align="center">
          <td>텍스트 붙여넣기</td>
        <td></td>
        <td>텍스트 복사</td>
        <td>Vim 종료</td>
    </tr>
    <tr align="center">
          <td>작업 취소</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
  </tbody>
</table>


<p>🌠 디폴트는 <code><strong>일반 모드</strong></code>로 실행. 다른 모드로 실행하려면 <code><strong>일반 모드</strong></code>를 거쳐야 한다.
<br /></p>
<h4 id="·-비주얼-모드-텍스트-복사-붙여넣기-잘라내기">· [비주얼 모드] 텍스트 복사, 붙여넣기, 잘라내기</h4>
<p><code>y</code>: 복사
<code>p</code>: 붙여넣기
<code>d</code>: 잘라내기
<br />1. 일반 모드에 가서 복사하고 싶은 위치에 커서를 이동한다.
2. 비주얼 모드(<code>V</code>)로 전환해서 복사, 붙여넣기, 잘라내기를 사용한다.</p>
<h4 id="·-일반-모드-텍스트-복사-붙여넣기-잘라내기">· [일반 모드] 텍스트 복사, 붙여넣기, 잘라내기</h4>
<p><code>yy</code>: 복사
<code>p</code>: 붙여넣기
<code>dd</code>: 잘라내기
<br /></p>
<h4 id="·-커맨드-모드-vim-종료하기">· [커맨드 모드] vim 종료하기</h4>
<p><code>w</code>: 파일 저장
<code>q</code>: vim 종료</p>
<pre><code class="language-bash"># 신규 파일 저장
# w + 파일 명
:w hello_world.txt

# hello_world.txt 열기
vim hello_world.txt

# hello_world.txt 내용 수정 후,
# 저장함과 동시에 vim 종료
:wq

# 파일 저장 없이 vim 종료 시
:q!</code></pre>
<p><br /><br /></p>
<h2 id="✅-파일-내용-살펴보기">✅ 파일 내용 살펴보기</h2>
<p>파일 내용을 확인하고 싶을 때, vim으로 파일을 열어봐도 되지만 더 간단한 방법들이 있다.
🌠** 상황에 따라 필요한 커맨드를 골라서 사용해보자.**</p>
<h3 id="cat">cat</h3>
<p><code>cat(concatenate)</code>은 파일을 조회할 때 자주 사용하는 커맨드.
파일의 내용을 간단히 보고 싶을 때 사용한다.</p>
<pre><code class="language-bash">cat PATH1 PATH2 ...</code></pre>
<pre><code class="language-bash">root@ubuntu:~/unix_practice/music# ls
bohemian_rhapsody.txt  killer_queen.txt

# cat 실행
cat bohemian_rhapsody.txt
Is this the real life?
Is this just fantasy?
Caught in a landside,
No escape from reality
Open your eyes,
Look up to the skies and see,
 .
 . 
 .
# 이어 붙일 수도 있다.
cat bohemian_rhapsody.txt killer_queen.txt</code></pre>
<br />

<h3 id="less">less</h3>
<p><code>cat</code>이 파일 내용을 한꺼번에 출력해 줬다면, <code>less</code>는 파일 내용을 페이지 단위로 나눠서 보여준다.
파일 내용이 길다면, <code>less</code>커맨드를 사용해보자.</p>
<pre><code class="language-bash">less index.txt</code></pre>
<p>이동할 땐 방향키를 사용한다.</p>
<table border="1" width="100%">
  <thead>
    <col width="15%" />
    <col width="35%" />
     <col width="15%" />
    <col width="35%" />
  </thead>
  <tbody>
    <tr>
      <th scope="col">위로 이동</th>
      <td>위쪽 방향키</td>
      <th scope="col">아래 이동</th>
      <td>아래 방향키</td>
    </tr>
    <tr>
      <th scope="col">다음 페이지</th>
      <td>스페이스바, f</td>
      <th scope="col">이전 페이지</th>
      <td>b</td>
    </tr>
    <tr>
      <th scope="col">마지막 페이지</th>
      <td>대문자 G</td>
      <th scope="col">첫 페이지</th>
      <td>소문자 g</td>
    </tr>
    <tr>
      <th scope="col">종료</th>
      <td>q</td>
      <th scope="col"></th>
      <td></td>
    </tr>
  </tbody>
</table>
<br /><br />

<h3 id="head-tail">head, tail</h3>
<p><code>head</code>와 <code>tail</code>은 이름에서 느껴지듯, 커맨드는 파일의 시작 부분이나 끝 부분을 확인할 때 사용한다.</p>
<h4 id="head">head</h4>
<pre><code class="language-bash">head index.txt
# 입력 시, 파일 첫 10줄이 출력된다.</code></pre>
<h4 id="tail">tail</h4>
<pre><code class="language-bash">tail index.txt
# 입력 시, 파일 마지막 10줄이 출력된다.</code></pre>
<p><code>head</code>나 <code>tail</code> 커맨드가 보여주는 줄 개수도 변경해 줄 수 있다.</p>
<pre><code class="language-bash">head or tail [-n count] PATH

head -n 5 index.txt
tail -n 5 index.txt
# 출력할 줄 개수를 -n 옵션의 아규먼트로 넘겨주면 된다.</code></pre>
<p><br /><br /></p>
<h2 id="✅-파일과-디렉토리-옮기기--이름-변경하기">✅ 파일과 디렉토리 옮기기 &amp; 이름 변경하기</h2>
<h3 id="mv">mv</h3>
<p>실행에 사용되는 커맨드가 똑같아서 같이 묶었다.
둘 다 <code>move</code>를 줄인 <code>mv</code>라는 커맨드를 사용하는데, <code>mv</code> 커맨드는 <strong>아규먼트로 파일</strong>이나 <strong>디렉토리 경로</strong>  두 개를 받는다.</p>
<pre><code class="language-bash"># path1: 작업할 대상의 경로
# path2: 이동할 목적지 또는 변경할 이름
mv path1 path2

# 1. 이름 바꾸기
mv old.txt new.txt
ls
new.txt

# 이름을 변경하려는데 기존에 있는 이름이 존재하는 경우
# Aug Jul Sep
mv Jul Aug
ls
Aug Sep
ls Aug
# Aug 디렉토리 안으로 들어가버렸다.
Jul

# 2. 다시 밖으로 꺼내기(옮기기)
mv Aug/Jul . (.은 현재 위치, 경로)
ls
Aug Jul Sep

# 3. 파일을 디렉토리 안으로 옮기기
#Aug Jul Oct Sep file.txt
mv file.txt Sep</code></pre>
<h4 id="🌠-mv-커맨드-사용-시-주의할-점">🌠 mv 커맨드 사용 시 주의할 점</h4>
<h4 id="-i">-i</h4>
<p>우리가 평소에 사용하는 <code>GUI</code> 환경에서는 파일을 이동할 때, 같은 이름의 파일이 있으면 파일을 덮어쓸 것인지, 작업을 취소할 것인지 물어보지만 <code>mv</code> 커맨드는 <strong>똑같은 이름의 파일이 목적지에 있을 경우 덮어쓴다</strong>는 점이다.</p>
<p>이런 현상을 방지하고 싶으면, <code>i</code>(interactive) 옵션을 사용한다.</p>
<pre><code class="language-bash">mv [-i] SOURCE_PATH DEST_PATH

# 덮어 쓰려면 y, 취소는 n을 입력하면된다.
mv -i file1.txt file2.txt
overwrite file2.txt? (y/n [n])</code></pre>
<p><br /><br /></p>
<h2 id="✅-파일과-디렉토리-복사-붙여넣기">✅ 파일과 디렉토리 복사 붙여넣기</h2>
<h3 id="cp">cp</h3>
<p><code>cp</code> 커맨드는 <code>copy</code>의 줄임말.
<code>cp</code> 커맨드도 <code>mv</code> 커맨드와 마찬가지로 똑같은 이름의 파일이 목적지에 있을 경우 덮어쓴다.</p>
<pre><code class="language-bash"># path1: 첫번째 아규먼트는 복사할 대상의 경로를 전달
# path2: 두번째 아규먼트는 복사할 위치를 전달
cp path1 path2
# path2 아규먼트가 이미 존재하는 디렉토리라면 그 안으로 복사되고,
# 아니라면 path2 이름을 가진 파일 또는 디렉토리가 생성된다.

# 파일이 아닌, 디렉토리를 복사할 때는 r 옵션을 추가 해야한다.
cp -r name name_copy
ls
name name_copy
ls name_copy
con.txt con2.txt con3.txt
# name 디렉토리 안에 있던 자식 디렉토리, 파일들까지 모두 복사</code></pre>
<h4 id="-r">-r</h4>
<p>디렉토리를 복사할 때</p>
<h4 id="-i-1">-i</h4>
<p>복사할 때 똑같은 이름의 파일 확인</p>
<p><br /><br /></p>
<h2 id="✅-파일과-디렉토리-삭제하기">✅ 파일과 디렉토리 삭제하기</h2>
<h3 id="rm">rm</h3>
<p><code>rm</code> 커맨드는 <code>remove</code>의 줄임말.</p>
<pre><code class="language-bash"># rm은 지우고 싶은 파일이나 디렉토리를 여러 개 아규먼트로 줄 수 있다.
cp path1 path2 path3 ...

# cp와 마찬가지로 디렉토리를 지울때는 r 옵션을 추가한다.
rm -r name

# rm의 i 옵션은 각 파일을 지우기 전에 확실히 지울 것인지 물어보는 옵션이다.
rm -ri name
examine files in directory name? [n or y]
remove name/file1.txt? y
remove name/file2.txt? y
remove name/file3.txt? y
remove name? y

# 커맨드 라인으로 파일을 지우면 영구적으로 지워지기 때문에 유의.

# f옵션은 i옵션과 다르게 바로 지워줌.
# 예를 들어 읽기 전용 파일을 지울 때는 보통 파일을 지울 것인지 물어보는데,
# f옵션은 물어보지 않고 그냥 지운다.
rm -rf path/to/dir
</code></pre>
<h4 id="-r-1">-r</h4>
<p>디렉토리를 삭제할 때</p>
<h4 id="-i-2">-i</h4>
<p>삭제할 때 각 파일을 정말 지울 것인지 확인</p>
<h4 id="-f">-f</h4>
<p>지울 것인지 절대 확인하지 않음
<br /><br /></p>
<hr />
<h2 id="참고자료">참고자료</h2>
<p>코드잇 토픽
<a href="https://en.wikipedia.org/wiki/Unix_file_types">https://en.wikipedia.org/wiki/Unix_file_types</a>
<a href="https://averagelinuxuser.com/linux-root-folders-explained/">https://averagelinuxuser.com/linux-root-folders-explained/</a></p>